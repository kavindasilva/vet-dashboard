import React, { Component } from "react";

// https://react-day-picker.js.org/
import DayPicker from 'react-day-picker';
import 'react-day-picker/lib/style.css';

import InfiniteCalendar from 'react-infinite-calendar';
import 'react-infinite-calendar/styles.css';

import DateFnsUtils from "@date-io/date-fns";
import {format} from "date-fns";
import {  DatePicker,  TimePicker,  DateTimePicker,  MuiPickersUtilsProvider } from "@material-ui/pickers";

import '@y0c/react-datepicker/assets/styles/calendar.scss';

import { withStyles } from '@material-ui/core/styles';
import Button from '@material-ui/core/Button';
import Dialog from '@material-ui/core/Dialog';
import DialogActions from '@material-ui/core/DialogActions';
import DialogContent from '@material-ui/core/DialogContent';
import DialogContentText from '@material-ui/core/DialogContentText';
import DialogTitle from '@material-ui/core/DialogTitle';
import Paper from '@material-ui/core/Paper';
import Draggable from 'react-draggable';
import Select from '@material-ui/core/Select';
import Radio from '@material-ui/core/Radio';
import Checkbox from '@material-ui/core/Checkbox';
import TextField from '@material-ui/core/TextField';

import Popup from "reactjs-popup";

import TableCell from '@material-ui/core/TableCell';

import { connect } from "react-redux";
import rootReducer from "../reducers/index";

import { rootStore } from "../stores/pets";
import { MenuItem, RadioGroup, FormControlLabel, FormGroup } from "@material-ui/core";

import Moment from 'react-moment';
import moment from "moment";

//import Checkbox from "./checkBoxComp";

const evaluate=()=>{
	
}

//export default class PopDialog extends Component {
class PopDialog extends Component {
	state = {
		/** trackerInstaid. need in dispatching */	trackerInstanceIdId		:this.props.trackerInstanceId,
		/** column id. need in dispatching */	columnId		:this.props.instanceData.columnId,
		/** property value */     				attributeValue	:this.props.instanceData.value,
		/** property name */      				attributeName	:this.props.property,
		/** element input type */ 				elementType		:this.props.elementType,
		/** Detect popup modal open state */	isOpen			:false,
		//** temporary day to keep calendar selected date */ tempDayCal: this.props.value,
		//** data location Hubspot / DB */		dataLocation: 'db', //hubspot data not edited!
		
		
		/** for the styles generated by BG scripts */
		styleScript: {
			//backgroundColor: "orange",
			//backgroundColor: eval( this.props.configData.columns[4].rules[0].bgcolor ),
			backgroundColor: {
				...this.props.configData.rules[0]
			}.bgcolor ,
		}

	}

	/** 
	 * defined by columnId
	 * 
	 * columnId: { predefined value set }
	 * */
	columnPredefinedValues ={
		1: null,				// clinic name

		4: 0,					// RF sent date
		5: null,				// RF completed date
		6: [ { name:true, value:"OK" }, { name:false, value:"NotCompleted"} ],		// completed status
		7: 24					// total duration
	}

	/** style for the table's div content */
	styleTD={
		width: "100%" ,
		minHeight: "18px",
		color: "#111111"
	}

	styleMatUI={
		closeButton: {
			cursor:'pointer', 
			float:'right', 
			marginTop: '5px', 
			width: '20px',
			align: 'right'
		},

		titleBarThin:{
			padding: "0 24 0 24"
		},

		titleBarPrimary:{
			color:"white", "backgroundColor":"#3c4fb0"
		}
	}	

  	render() {
		console.log('Rendering cell content');
		return (
			<React.Fragment>
				<TableCell 
					align={ (isNaN(this.props.instanceData.value))?'left':'right' } 
					style={ this.state.styleScript }
				>
					{ this.showPop() }
				</TableCell>
			</React.Fragment>
		)
	}

	showPop(){
		//console.log("generating cell input elements", this.props.instanceData, this.state);
		if(this.state.elementType ==="date" ){
			//console.log("tracker popup1MatUI:",this.props.instanceData.value);
			return(
				<React.Fragment>
					<div style={this.styleTD}
						onClick={ ()=>{ 
							this.openPopUp();
							//console.log( "Popoup clicked: ",this ); 
						} } 
					>
						{ String(this.props.instanceData.value) }
					</div>

					{/* popup modal UI */}
					<Dialog
						open={this.state.isOpen}
						onClose={this.closePopUp}
						aria-labelledby="draggable-dialog-title"
					>
						{/* <AppBar position="relative" ></AppBar> */}
						<DialogTitle id="draggable-dialog-title" 
						style={
							{ ...this.styleMatUI.titleBarPrimary,  padding: "18px 24px 16px 24px" }
						}
						>

							Change { this.state.attributeName }

						</DialogTitle>

						<DialogContent>
								{ this.makeInputElements() }		
						</DialogContent>

						<DialogActions>
							<Button onClick={ ()=>{
									this.setState({ attributeValue: this.props.instanceData.value });
									this.closePopUp() 
								} }
								style={ this.styleMatUI.closeButton }	
								variant="text"
								color="primary"
							>
								Cancel
							</Button>
												
							<Button onClick={ () => { 
									//this.setState({ attributeValue:this.state.attributeValue });
									this.dispatchUpdate()
									this.closePopUp(); 
								} } 
								variant="text" color="primary"
								style={this.styleMatUI.closeButton} >OK
							</Button>
						</DialogActions>
					</Dialog>
				
				</React.Fragment>
			);
		}
		else{
			return(
				<div style={this.styleTD}>
					test{ String(this.props.instanceData.value) }
					<Popup 
						trigger={ <span > {
							String(this.props.instanceData.value)
							}  </span>  } 
						position="bottom right"
					>
						{this.showIntantPopup()}
					</Popup>
				</div>
			);
		}
		
	}

	/** small popup box */
	showIntantPopup = () => (
		close => (
			<div>
				<a href="#" className="close" onClick={close}> &times; </a>
				<br/>
				{ this.makeInputElements() } <br/>
									
				<Button onClick={ (e) => { 
						//e.preventDefault();
						//this.setState({ attributeValue:this.state.attributeValue });
						this.dispatchUpdate();
						close(); 
					} } 
					variant="text" color="primary"
					style={this.styleMatUI.closeButton} 
				>
					OK
				</Button>

			</div>
		)
	)

	/** not used for now */
	Pop2_1 = () => (
		close => (
			<div>
				<a href="#" className="close" onClick={close}> &times; </a>
				{ /*this.tempValue=this.state.name*/ }
				<b>Change { this.state.attributeName } </b> <br/>
				<input type="text" name="txtName" value={this.state.attributeValue} 
					onChange={ e => this.setState({ attributeValue: e.target.value }) }  /> <br/>

				<a onClick={close} >
					<button onClick={ () => { this.setState({ name:this.state.name }); } } className="btn btn-sm btn-link" >OK</button>
				</a>
				{<a onClick={close} >
					<button onClick={ () => this.setState({ name:this.props.name }) } className="btn btn-sm btn-link" >Cancel</button>
				</a>}
			</div>
		)
	)

	/**
	 * Update the store
	 * DB update should be called in the reducer
	 */
	dispatchUpdate = () => {
		rootStore.dispatch({
			type: 'UPDATE_CELL_VALUE',
			payload: {
				trackerInstanceId: this.state.trackerInstanceIdId,
				columnId: this.state.columnId,
				value: this.state.attributeValue
				// trackerInstanceIdId: 1,
				// columnId: 7,
				// value: 50
			}
		});
	}

	makeInputElements= () =>{
			switch (this.props.elementType) {
				case "text":
				case "number":
					return(
						<TextField
							label={ this.state.attributeName }
							value={this.state.attributeValue}
							onChange={ e => (
								e.preventDefault(),
								this.setState({ attributeValue: e.target.value }),
								console.log('New Value', e.target.value, this.state.attributeValue)
								) }

							type={ this.state.elementType }
						/>
					);

				case "select":
					return (
						<React.Fragment>
							<br />
							<Select value={ this.state.attributeValue } 
								onChange={ e => this.setState({ attributeValue: e.target.value }) }
								fullWidth={true}
							>
								{
									this.props.data.valueSet.map( item =>
											<MenuItem key={ item.value } value={ item.value } >{ item.label }</MenuItem>
										)
								}
							</Select>
						</React.Fragment>
					);

				case "radio2": // testing for small popup// not used for now
					return(
						<Popup trigger={ <span > { this.state.name }  </span>  } position="bottom left">
							{close => (
								<div>
									<a href="#" className="close" onClick={close}> &times; </a>
									{ /*this.tempValue=this.state.name*/ }
									<b>Change Name</b> <br/>
									<input type="text" name="txtName" value={this.state.name} 
										onChange={ e => this.setState({ name: e.target.value }) }  /> <br/>

									<a onClick={close} >
										<button onClick={ () => { this.setState({ name:this.state.name }); } } className="btn btn-sm btn-link" >OK</button>
									</a>
									{<a onClick={close} >
										<button onClick={ () => this.setState({ name:this.props.name }) } className="btn btn-sm btn-link" >Cancel</button>
									</a>}
								</div>
							)}
						</Popup>
					)

				case "radio": //popup
					return (
						<RadioGroup
							name="genderSelect"
							value={ this.state.attributeValue }
							onChange={ (e)=>{
								this.setState({ attributeValue: e.target.value});
								console.log(e)
								}
							}
						>	
							{ this.columnPredefinedValues[6].map( val => (
								<FormControlLabel
									key={ String(val.name) }
									value={ String(val.name) }
									control={<Radio color="primary" />}
									label={ val.value }
									labelPlacement="end"
									/>
								)
							)}
							
						</RadioGroup>
					);

				case "checkBox":
					return(
						<FormGroup>
							{this.props.data.valueSet.map( (val, index) => (
								<div key={index} >
									<FormControlLabel
										control={ 
											<Checkbox
												key={index}
												checked={
													this.state.attributeValue.includes( val.name)/**/
												}
												onChange={ (e)=>{
													if(e.target.checked){
															this.setState({
																	attributeValue: [...this.state.attributeValue, e.target.value]
															})
													}
													else{ 
															var index = this.state.attributeValue.indexOf(e.target.value);
															if (index > -1) {
																//prevState.list.filter( itm=> itm != index);
																let newArr = [...this.state.attributeValue]; //
																	newArr.splice(index, 1);
																	this.setState({
																			attributeValue: newArr
																	})
															} 
													}
												}}

												value={val.name}
												color="primary"
											/>
										}
										style={ { width: "100%" } }
										label={ val.value }
									>
									</FormControlLabel>

								</div>
							)
							)}
						</FormGroup>
					);

				case "date":
					return(
						<MuiPickersUtilsProvider utils={DateFnsUtils} onClick={() =>  this.setState({ isOpen: true}) }>
							<DatePicker
								autoFocus = { false }
								//onlyCalendar
								//variant="inline"
								format="yyyy/MM/dd"
								label="Pet admitted date"
								//helperText="No year selection"
								value={ this.state.attributeValue }
								onChange={ this.changeDatepickerValue }
								onAccept={ this.acceptDatepickerValue }
								open={ this.state.isOpen }
								onOpen={ this.openDatepicker }
								onClose={ this.closeDatepicker }
								onClick={ this.openDatepicker }
							/>
							</MuiPickersUtilsProvider>
					);
				
				default:
					console.log("invalid case");
					break;
			}
	}

	openPopUp = () => {
		this.setState({ isOpen: true });
	};

	closePopUp = () => {
		this.setState({ isOpen: false });
	};

	openDatepicker = () => {
		this.setState({ isOpen: true})
	}
	closeDatepicker = () => {
		this.setState({ isOpen: false})
	}
	changeDatepickerValue = (selectedDate) => {
		this.setState({ attributeValue: format(new Date(selectedDate), 'yyyy-MM-dd') });
	}

	acceptDatepickerValue = () => {
		this.dispatchUpdate();
	}

	componentDidMount(){
		console.log("trackerPopup didmount props:", this.props);
		//console.log("trackerPopup didmount moment:", moment().endOf('day').fromNow() ); // ok  in 8 hours
		//console.log("trackerPopup didmount moment:", Moment.endOf('day').fromNow() );
		//console.log("trackerPopup didmount propspart2:", {...this.props.configData.rules[0]}.bgcolor );
		//console.log("trackerPopup didmount propspart2:", eval({...this.props.configData.rules[0]}.conditions) );
		//console.log("trackerPopup didmount propspart2:", eval( 3+5 ) ); // ok 8
	}

}

function PaperComponent(props) {
  return (
    <Draggable>
      <Paper {...props} />
    </Draggable>
  );
}

const mapStateToProps = (state, props) => {
	//console.log('trackerPopup.jsx-mapStateToProps', state);

	/** tracker's instance's index */
	let trackerIndex = state.TrackInstaReducer.instanceData.findIndex( tracker => (
		tracker.id === props.trackerInstanceId
	) );

	/** tracker's config's index */
	let trackerConfigIndex = state.TrackConfigReducer.configData.findIndex(tracker => (
		tracker.id === props.trackerId
	));

	/** tracker's config's column data */
	var trackerConfig = null;
	if(trackerConfigIndex>-1){
		trackerConfig = state.TrackConfigReducer.configData[trackerConfigIndex].columns.find(column => (
			column.id === props.columnId
		));
	}
	else
		console.log("trackerPopup trackerConfigIndex error");


	let data = state.TrackInstaReducer.instanceData[trackerIndex].data.find( column => (
		column.columnId === props.columnId
	) );
	if( trackerIndex > -1 ){
		let response = {
			configData: trackerConfig,

			metaData: state.MetaReducer.metaData,

			instanceData: state.TrackInstaReducer.instanceData[trackerIndex].data.find( column => (
				column.columnId === props.columnId
			) )

			//configData: state.TrackConfigReducer.configData,
		};

		//console.log('instanceData', trackerIndex, props.columnId, data, response);

		return response;

	}
	else
		console.log("trackerPopup indexError")
}

/** NOT connected with store since this component is called only by the TrackerTableData */
//export default PopDialog;
export default connect(mapStateToProps)(PopDialog);

//export default withStyles(styles)(PopDialog);
//export default withStyles()(PopDialog);

